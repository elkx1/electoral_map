<!DOCTYPE html>
<html>

<head>
    <title>Election Results Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="https://unpkg.com/d3-simple-slider"></script>
</head>

<body>

    <div id="map"></div>

    
    <div id="chart-container"></div>
    <div id="slider-range"></div>

    <script>
        // DATA SOURCES:
        // 
        //  TopoGEO shapes: https://martinjc.github.io/UK-GeoJSON/
        //  Electoral results: https://www.electoralcalculus.co.uk/flatfile.html
        //

        // Width and height of the SVG container
        const width = 1200;
        const height = 800;

        const svg = d3.select("#chart-container")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        //   svg.append("rect")
        //     .attr("width", "100%")
        //     .attr("height", "100%")
        //     .attr("fill", "pink");

        // Projection using geoMercator
        const projection = d3.geoMercator()
            .scale(4000)
            .center([-4.5, 54.3]);

        // Create a GeoPath generator
        const path = d3.geoPath().projection(projection);

        // Alias mapping between constituency names in election data and GeoJSON data
        const aliasMapping = {
            // "ElectionName": "GeoJSONName",
            // Add more aliases as needed

            // "Ashton under Lyne": "Ashton-under-Lyne",
            // "Surrey South West": "South West Surrey",
            "Kingston upon Hull West and Hessle": "Hull West and Hessle",
            "Kingston upon Hull East": "Hull East",
            "Kingston upon Hull North": "Hull North",
            "South Basildon and East Thurrock": "Basildon South and East Thurrock",
            "Richmond (Yorks)": "Richmond",
        };

        function getAliasMappings(name) {
            aliases = [name.replaceAll("-", " ").replaceAll(",", "")];

            if (name in aliasMapping) {
                aliases.push(aliasMapping[name]);
            }

            const swappedEndings = [
                { "name": "North West", "has_comma": false },
                { "name": "North East", "has_comma": false },
                { "name": "South East", "has_comma": false },
                { "name": "South West", "has_comma": false },
                { "name": "Central", "has_comma": false },
                { "name": "North", "has_comma": false },
                { "name": "East", "has_comma": false },
                { "name": "South", "has_comma": false },
                { "name": "West", "has_comma": false },
                { "name": "Mid", "has_comma": false }, // Pretty mid
                { "name": "City of", "has_comma": true },
                { "name": "The", "has_comma": true },
            ];

            function swapEndings(namePart) {
                let foundAlias = null;
                for (const special of swappedEndings) {
                    specialName = special["name"]
                    if (namePart.startsWith(specialName + " ")) {
                        foundAlias = namePart.substring(specialName.length + 1, namePart.length) + (special["has_comma"] ? "," : "") + " " + specialName;
                        break;
                    }
                }
                return foundAlias;
            }

            if (name.includes("and")) {
                let partAliases = [];
                for (const part of name.split(" and ")) {
                    let swapped = swapEndings(part);
                    if (swapped == null) {
                        partAliases.push(part);
                    }
                    else {
                        partAliases.push(swapped);
                    }
                }
                aliases.push(partAliases.join(" and "));
                aliases.push(partAliases.reverse().join(" and "));
            }
            else {
                aliases.push(swapEndings(name))
            }

            return aliases;
        }

        // Define colors for parties
        const partyColors = {
            "CON": "blue",
            "LAB": "red",
            "LIB": "yellow",
            "Brexit": "purple",
            "Green": "green",
            "NAT": "pink",
            "MIN": "pink",
            "OTH": "pink",
        };
        const getPartyColor = function (name) {
            if (name in partyColors) {
                return partyColors[name];
            }
            return "black";
        }

        // let electionFile = "data/electdata_2019.txt";
        // let electionFile = "data/electdata_2017.txt";
        // let electionFile = "data/electdata_2015.txt";
        // let electionFile = "data/electdata_2010ug.txt";
        let electionFile = "data/electdata_2005nb.txt";
        
        const sliderRange = d3.sliderBottom()
            .min(0)
            .max(4)
            .width(300)
            .ticks(5)
            .default(4)
            .step(1)
            .fill('#85bb65');
            
        // sliderRange.on('onchange', val => {
        //     d3.dsv(";", electionFile)
        //     path.data
        // })
        const gRange = d3
            .select('#slider-range')
            .append('svg')
            .attr('width', 500)
            .attr('height', 100)
            .append('g')
            .attr('transform', 'translate(90,30)');

        gRange.call(sliderRange);

        // Load GeoJSON data from a file
        d3.json("data/topo_westminster_parliamentary_constituencies_2014.json").then(function (mapData) {
            d3.dsv(";", electionFile).then(function (electionData) {
                // Extract parties from the CSV header row
                const parties = electionData.columns.filter(col => col !== 'Name' && col !== 'MP' && col !== 'Area' && col !== 'County' && col !== 'Electorate');

                // Create a map of constituency names to winning parties
                const winningParties = {};
                electionData.forEach(result => {
                    const constituency = result.Name;
                    const partyScores = parties.map(party => ({ party, score: parseInt(result[party]) }));

                    const winningParty = partyScores.reduce((prev, current) => (prev.score > current.score ? prev : current)).party;
                    winningParties[constituency] = winningParty;

                    // console.log("Winnning party for " + constituency + ": " + winningParty)
                });

                // Render the map
                svg.selectAll("path")
                    .data(topojson.feature(mapData, mapData.objects.wpc).features)
                    .enter().append("path")
                    .attr("d", path)
                    .attr("fill", function (d) {
                        const constituencyName = d.properties.PCON13NM; // Adjusted according to the topojson structure

                        let matchingName = null;

                        // Check if the constituency name exists in election data
                        if (constituencyName in winningParties) {
                            matchingName = constituencyName;
                        } else {
                            // Check aliases
                            var aliases = getAliasMappings(constituencyName)
                            // console.log("aliases for " + constituencyName + ": " + aliases)
                            aliases.forEach(alias => {
                                if (alias in winningParties) {
                                    matchingName = alias;
                                }
                            })
                        }

                        if (matchingName == null) {
                            console.log("No match found for constituency name " + constituencyName);
                            return "black";
                        }

                        const winningParty = winningParties[matchingName];
                        return getPartyColor(winningParty);

                        // const winningParty = winningParties[matchingName];

                        // Define colors for parties
                        // const partyColors = {
                        // Define colors for each party dynamically
                        // };

                        // return partyColors[winningParty];
                        // return 'red';
                    });


                //   .attr("fill", function(d) {
                //     // Your code to determine and apply colors based on election results
                //     // ...
                //   });
            })
        });
    </script>

</body>

</html>