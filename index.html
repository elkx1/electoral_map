<!DOCTYPE html>
<html>

<head>
    <title>Election Results Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="https://unpkg.com/d3-simple-slider"></script>
</head>

<body>

    <div id="map"></div>

    
    <div id="chart-container"></div>
    <div id="slider-range"></div>

    <script>
        // DATA SOURCES:
        // 
        //  TopoGEO shapes: https://martinjc.github.io/UK-GeoJSON/
        //  Electoral results: https://www.electoralcalculus.co.uk/flatfile.html
        //

        // Width and height of the SVG container
        const width = 1200;
        const height = 800;

        const svg = d3.select("#chart-container")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        //   svg.append("rect")
        //     .attr("width", "100%")
        //     .attr("height", "100%")
        //     .attr("fill", "pink");

        // Projection using geoMercator
        const projection = d3.geoMercator()
            .scale(4000)
            .center([-4.5, 54.3]);

        // Create a GeoPath generator
        const path = d3.geoPath().projection(projection);

        // Alias mapping between constituency names in election data and GeoJSON data
        const aliasMapping = {
            // "ElectionName": "GeoJSONName",
            // Add more aliases as needed

            // "Ashton under Lyne": "Ashton-under-Lyne",
            // "Surrey South West": "South West Surrey",
            "Kingston upon Hull West and Hessle": "Hull West and Hessle",
            "Kingston upon Hull East": "Hull East",
            "Kingston upon Hull North": "Hull North",
            "South Basildon and East Thurrock": "Basildon South and East Thurrock",
            "Richmond (Yorks)": "Richmond",
        };

        function getAliasMappings(name) {
            aliases = [name.replaceAll("-", " ").replaceAll(",", "")];

            if (name in aliasMapping) {
                aliases.push(aliasMapping[name]);
            }

            const swappedEndings = [
                { "name": "North West", "has_comma": false },
                { "name": "North East", "has_comma": false },
                { "name": "South East", "has_comma": false },
                { "name": "South West", "has_comma": false },
                { "name": "Central", "has_comma": false },
                { "name": "North", "has_comma": false },
                { "name": "East", "has_comma": false },
                { "name": "South", "has_comma": false },
                { "name": "West", "has_comma": false },
                { "name": "Mid", "has_comma": false }, // Pretty mid
                { "name": "City of", "has_comma": true },
                { "name": "The", "has_comma": true },
            ];

            function swapEndings(namePart) {
                let foundAlias = null;
                for (const special of swappedEndings) {
                    specialName = special["name"]
                    if (namePart.startsWith(specialName + " ")) {
                        foundAlias = namePart.substring(specialName.length + 1, namePart.length) + (special["has_comma"] ? "," : "") + " " + specialName;
                        break;
                    }
                }
                return foundAlias;
            }

            if (name.includes("and")) {
                let partAliases = [];
                for (const part of name.split(" and ")) {
                    let swapped = swapEndings(part);
                    if (swapped == null) {
                        partAliases.push(part);
                    }
                    else {
                        partAliases.push(swapped);
                    }
                }
                aliases.push(partAliases.join(" and "));
                aliases.push(partAliases.reverse().join(" and "));
            }
            else {
                aliases.push(swapEndings(name))
            }

            return aliases;
        }

        // Define colors for parties
        const partyColors = {
            "CON": "blue",
            "LAB": "red",
            "LIB": "yellow",
            "Brexit": "purple",
            "Green": "green",
            "NAT": "pink",
            "MIN": "pink",
            "OTH": "pink",
        };
        function getPartyColor(name) {
            if (name in partyColors) {
                return partyColors[name];
            }
            return "black";
        }

        function clearPaths() {
            svg.selectAll("path").remove();
        }

        function drawMappedData(features, dataSetCachedData) {
            // Render the map
            svg.selectAll("path")
                .data(features)
                .enter().append("path")
                .attr("d", path)
                .attr("fill", function (d) {
                    return dataSetCachedData.features[d.id].fill;
                });
        };

        function computeDataSetCachedData(dataSet) {
            // Extract parties from the CSV header row
            const parties = dataSet.columns.filter(col => col !== 'Name' && col !== 'MP' && col !== 'Area' && col !== 'County' && col !== 'Electorate');

            // Create a map of constituency names to winning parties
            const winningParties = {};
            dataSet.forEach(result => {
                const constituency = result.Name;
                const partyScores = parties.map(party => ({ party, score: parseInt(result[party]) }));

                const winningParty = partyScores.reduce((prev, current) => (prev.score > current.score ? prev : current)).party;
                winningParties[constituency] = winningParty;

                // console.log("Winnning party for " + constituency + ": " + winningParty)
            });

            return {"winningParties": winningParties};
        }

        function computeFeatureData(feature, mappedDataSet, dataSetCachedData) {
            // Adjust for the particular property name in the topojson file
            const constituencyName = feature.properties.PCON13NM;
            
            let matchingName = null;

            // Check if the constituency name exists in election data
            if (constituencyName in dataSetCachedData.winningParties) {
                matchingName = constituencyName;
            } else {
                // Check aliases
                var aliases = getAliasMappings(constituencyName)
                // console.log("aliases for " + constituencyName + ": " + aliases)
                aliases.forEach(alias => {
                    if (alias in dataSetCachedData.winningParties) {
                        matchingName = alias;
                    }
                })
            }

            if (matchingName == null) {
                console.log("No match found for constituency name " + constituencyName);
                return "black";
            }

            const winningParty = dataSetCachedData.winningParties[matchingName];
            return {"fill": getPartyColor(winningParty)};
        }

        function onDataLoaded(mapGeoJSON, mappedDataSetConfigs, mappedDataSets) {
            // The things we want to draw
            mapFeatures = topojson.feature(mapGeoJSON, mapGeoJSON.objects.wpc).features

            // Cache the drawing information
            allDataSetsCachedData = [];
            for (const dataSet of mappedDataSets) {
                dataSetCachedData = {};
                dataSetCachedData.root = computeDataSetCachedData(dataSet);
                dataSetCachedData.features = {};
                for (const feature of mapFeatures) {
                    dataSetCachedData.features[feature.id] = computeFeatureData(feature, dataSet, dataSetCachedData.root);
                }
                allDataSetsCachedData.push(dataSetCachedData);
            }

            numDataSets = mappedDataSets.length
            initialDataSet = numDataSets - 1
            const sliderRange = d3.sliderBottom()
                .min(0)
                .max(numDataSets - 1)
                .width(300)
                .ticks(numDataSets)
                .default(initialDataSet)
                .step(1)
                .fill('#85bb65')
                .tickFormat(function (tick) { return mappedDataSetConfigs[tick].id; });
            
            const gRange = d3
                .select('#slider-range')
                .append('svg')
                .attr('width', 500)
                .attr('height', 100)
                .append('g')
                .attr('transform', 'translate(90,30)');

            gRange.call(sliderRange);

            drawMappedData(mapFeatures, allDataSetsCachedData[initialDataSet]);

            sliderRange.on('onchange', val => {
                console.log("onchange", electionFiles[val].filename);
                clearPaths();
                drawMappedData(mapFeatures, allDataSetsCachedData[val]);
            })
        }

        mapGeoJSONFileName = "/data/topo_westminster_parliamentary_constituencies_2014.json";
        electionFiles = [
            {"id": "2005", "filename": "/data/electdata_2005nb.txt"},
            {"id": "2010", "filename": "/data/electdata_2010ug.txt"},
            {"id": "2015", "filename": "/data/electdata_2015.txt"},
            {"id": "2017", "filename": "/data/electdata_2017.txt"},
            {"id": "2019", "filename": "/data/electdata_2019.txt"},
        ];
        
        promises = [];
        promises.push(d3.json(mapGeoJSONFileName));
        for (const electionFile of electionFiles) {
            promises.push(d3.dsv(";", electionFile.filename));
        }

        Promise.all(promises).then(
            function (results) {
                mapGeoJSON = results[0];
                electionFilesData = results.slice(1);
                onDataLoaded(mapGeoJSON, electionFiles, electionFilesData);
            }
        )
    </script>

</body>

</html>