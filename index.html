<!DOCTYPE html>
<html>

<head>
    <title>Election Results Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v1.min.js"></script>
    <script src="https://unpkg.com/d3-simple-slider"></script>
    <script src="lib/simplify/simplify.js"></script>
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
</head>

<body>
    <div id="map"></div>

    
    <div id="chart-container"></div>
    <div id="slider-range"></div>

    <style>
        .tooltip-mapped-data {
            position: absolute;
            text-align: center;
            padding: .5rem;
            background: #FFFFFF;
            color: #313639;
            border: 1px solid #313639;
            border-radius: 8px;
            pointer-events: none;
            font-size: 0.8rem;
        }
    </style>

    <script>
        // DATA SOURCES:
        // 
        //  TopoGEO shapes: https://martinjc.github.io/UK-GeoJSON/
        //  Electoral results: https://www.electoralcalculus.co.uk/flatfile.html
        //
        // Feature ideas:
        //
        //  -> Filter by party
        //  -> Additional years
        //  -> Scotland & NI
        //  -> Other Countries
        //  -> Other election results data sets - e.g., predicted results by electoral calculus in that year
        //  -> More constituency details
        //  -> Politician voting record lookup direct from constituency
        //  -> Show county boundaries
        //  -> Search for constituency
        //  -> Constituency list
        // 

        // Width and height of the SVG container
        const width = 1200;
        const height = 800;

        const zoom = d3.zoom().scaleExtent([1, 16]).on("zoom", zoomed);

        const svg = d3.select("#chart-container")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        const g = svg.append("g");

        function zoomed(event) {
            const {transform} = event;
            g.attr("transform", transform);
        }

        svg.call(zoom);

        // Projection using geoMercator
        const projection = d3.geoMercator()
            .scale(4000)
            .center([-4.5, 54.3]);

        // Create a GeoPath generator
        const path = d3.geoPath().projection(projection);

        // Alias mapping between constituency names in election data and GeoJSON data
        const aliasMapping = {
            // "ElectionName": "GeoJSONName",
            // Add more aliases as needed

            // "Ashton under Lyne": "Ashton-under-Lyne",
            // "Surrey South West": "South West Surrey",
            "Kingston upon Hull West and Hessle": "Hull West and Hessle",
            "Kingston upon Hull East": "Hull East",
            "Kingston upon Hull North": "Hull North",
            "South Basildon and East Thurrock": "Basildon South and East Thurrock",
            "Richmond (Yorks)": "Richmond",
        };

        function getAliasMappings(name) {
            aliases = [name.replaceAll("-", " ").replaceAll(",", "")];

            if (name in aliasMapping) {
                aliases.push(aliasMapping[name]);
            }

            const swappedEndings = [
                { "name": "North West", "has_comma": false },
                { "name": "North East", "has_comma": false },
                { "name": "South East", "has_comma": false },
                { "name": "South West", "has_comma": false },
                { "name": "Central", "has_comma": false },
                { "name": "North", "has_comma": false },
                { "name": "East", "has_comma": false },
                { "name": "South", "has_comma": false },
                { "name": "West", "has_comma": false },
                { "name": "Mid", "has_comma": false }, // Pretty mid
                { "name": "City of", "has_comma": true },
                { "name": "The", "has_comma": true },
            ];

            function swapEndings(namePart) {
                let foundAlias = null;
                for (const special of swappedEndings) {
                    specialName = special["name"]
                    if (namePart.startsWith(specialName + " ")) {
                        foundAlias = namePart.substring(specialName.length + 1, namePart.length) + (special["has_comma"] ? "," : "") + " " + specialName;
                        break;
                    }
                }
                return foundAlias;
            }

            if (name.includes("and")) {
                let partAliases = [];
                for (const part of name.split(" and ")) {
                    let swapped = swapEndings(part);
                    if (swapped == null) {
                        partAliases.push(part);
                    }
                    else {
                        partAliases.push(swapped);
                    }
                }
                aliases.push(partAliases.join(" and "));
                aliases.push(partAliases.reverse().join(" and "));
            }
            else {
                aliases.push(swapEndings(name))
            }

            return aliases;
        }

        // Define colors for parties
        const partyColors = {
            "CON": "blue",
            "LAB": "red",
            "LIB": "yellow",
            "Brexit": "purple",
            "Green": "green",
            "NAT": "pink",
            "MIN": "pink",
            "OTH": "pink",
        };
        function getPartyColor(name) {
            if (name in partyColors) {
                return partyColors[name];
            }
            return "black";
        }

        function clearPaths() {
            svg.selectAll("path").remove();
        }

        var tooltipDiv = d3.select("body").append("div")
            .attr("class", "tooltip-mapped-data")
            .style("visibility", "hidden")
            .style("z-index", "0");

        function generateTooltipContents(feature, itemData) {
            tooltipDiv.html("")
            
            tooltipDiv.append("p").text(itemData.title);
            const pie = d3.pie()
                .value(function (d) { return d.score; } );
            const dataReady = pie(itemData.pieData);
            var width = 100;
            var height = 100;
            const div = tooltipDiv.append("svg")
                .style("width", width + "px")
                .style("height", height + "px")
                .append("g")
                .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
            div.selectAll(null)
                .data(dataReady)
                .enter()
                .append("path")
                .attr('d', d3.arc().innerRadius(width / 3).outerRadius(width / 2))
                .attr("fill", function(d) { return getPartyColor(d.data.party); });
        }

        function setMappedData(features, dataSetCachedData) {
            g.selectAll(".map-path")
                .attr("fill", function (d) {
                    return dataSetCachedData.features[d.id].fill;
                })
                .on('mouseover', function (d, feature) {
                    d3.select(this).transition()
                        .duration('50')
                        .attr('opacity', '.45')
                        .attr("stroke", "black")
                        .attr("stroke-width", "1px");

                    tooltipDiv.style("visibility", "visible");
                    tooltipDiv.append(generateTooltipContents(feature, dataSetCachedData.features[feature.id]));
                })
                .on('mousemove', function (d, feature) {
                    tooltipDiv
                        .style("left", (d.pageX + 10) + "px")
                        .style("top", (d.pageY - 15) + "px")
                        .style("position", "absolute");
                })
                .on('mouseout', function (d, feature) {
                    d3.select(this).transition()
                        .duration('50')
                        .attr('opacity', '1')
                        .attr("stroke", "black")
                        .attr("stroke-width", "0.1px");

                    tooltipDiv.style("visibility", "hidden");
                });
        }

        function drawMappedData(features, dataSetCachedData) {
            // Render the map
            var node = g.selectAll(".map-poly")
                .data(features)
                .attr("class", "map-poly")
                .enter()
                .append("g");

            node.append("clipPath")
                .attr("id", function(d) { return "clip" + d.id; })
                .append("path")
                .attr("d", path);
            
            node.append("path")
                .attr("class", "map-path")
                .attr("d", path)
                .attr("fill", function (d) {
                    return dataSetCachedData.features[d.id].fill;
                })
                .attr("stroke", "black")
                .attr("stroke-width", "0.1px")
                .attr("clip-path", function (d) { return "url(#clip" + d.id + ")"; });

            setMappedData(features, dataSetCachedData);
        };

        function computeDataSetCachedData(dataSet) {
            // Extract parties from the CSV header row
            const parties = dataSet.columns.filter(col => col !== 'Name' && col !== 'MP' && col !== 'Area' && col !== 'County' && col !== 'Electorate');

            // Create a map of constituency names to winning parties
            const winningParties = {};
            const votesByConstituencyName = {};
            dataSet.forEach(result => {
                const constituency = result.Name;
                const partyScores = parties.map(party => ({ party, score: parseInt(result[party]) }));

                const winningParty = partyScores.reduce((prev, current) => (prev.score > current.score ? prev : current)).party;
                winningParties[constituency] = winningParty;

                votesByConstituencyName[constituency] = partyScores;
                // console.log("Winnning party for " + constituency + ": " + winningParty)
            });

            return {"winningParties": winningParties, "votesByConstituencyName": votesByConstituencyName};
        }

        function computeFeatureData(feature, mappedDataSet, dataSetCachedData) {
            // Adjust for the particular property name in the topojson file
            const constituencyName = feature.properties.PCON13NM;
            
            let matchingName = null;

            // Check if the constituency name exists in election data
            if (constituencyName in dataSetCachedData.winningParties) {
                matchingName = constituencyName;
            } else {
                // Check aliases
                var aliases = getAliasMappings(constituencyName)
                // console.log("aliases for " + constituencyName + ": " + aliases)
                aliases.forEach(alias => {
                    if (alias in dataSetCachedData.winningParties) {
                        matchingName = alias;
                    }
                })
            }

            if (matchingName == null) {
                console.log("No match found for constituency name " + constituencyName);
                return "black";
            }

            const winningParty = dataSetCachedData.winningParties[matchingName];
            return {
                "title": constituencyName,
                "fill": getPartyColor(winningParty),
                "pieData": dataSetCachedData.votesByConstituencyName[matchingName],
            };
        }

        function filterBadPolygons(feature) {
            function isValid(poly) {
                return !(poly.length <= 4 && poly[0] == poly[poly.length - 1]);
            }
            
            if (feature.geometry.type == "MultiPolygon") {
                const minPolygonArea = 1e-5;
                feature.geometry.coordinates = feature.geometry.coordinates.map(polyList => polyList.filter(poly => d3.polygonArea(poly) > minPolygonArea));
            }
        }

        function simplifyMapFeature(feature) {
            // filterBadPolygons(feature);
            if (feature.properties.PCON13NM == "Wirral West") {
                console.log(feature);
            }
            filterBadPolygons(feature);
            // Simplifying the geometry of the map features improves render performance

            // todo rewrite the simplify library using my own impl of Douglas-Peucker, so we don't have
            // to swizzle this data like this

            function polygonArraysToDicts(poly) {
                return poly.map(function (point) { return {x: point[0], y: point[1]}; });
            }

            function polygonDictsToArrays(poly) {
                return poly.map(function (point) { return [point.x, point.y]; });
            }

            function simplifyPolygon(poly) {
                if (poly.length <= 4) {
                    // Otherwise the Isle of Wight disappears
                    return poly;
                }
                var dicts = polygonArraysToDicts(poly);
                var simplified = simplify(dicts, 0.001, true);
                var arrays = polygonDictsToArrays(simplified);
                return arrays;
            }

            // todo should do different things for multipolygon vs polygon
            if (feature.geometry.type == "MultiPolygon") {
                feature.geometry.coordinates = feature.geometry.coordinates.map(polyList => polyList.map(simplifyPolygon));
                // feature.geometry.coordinates = [];
            }
            else if (feature.geometry.type == "Polygon") {
                feature.geometry.coordinates = feature.geometry.coordinates.map(simplifyPolygon);
            }
            else {
                throw new Error("Unsupported geometry '" + feature.geometry.type + "'");
            }
        }

        function simplifyMapFeaturesOld(mapFeatures) {
            // Filter out invalid geometries
            for (feature of mapFeatures) {
                simplifyMapFeature(feature);
            }
            return mapFeatures;
        }

        function simplifyMapFeatures(mapFeatures) {
            // Filter out invalid geometries
            for (feature of mapFeatures) {
                filterBadPolygons(feature);
            }

            var featureCollection = {
                type: "FeatureCollection",
                features: mapFeatures
            };

            // Buffer the point by 10 units
            var buffered = turf.buffer(featureCollection, 0, { units: 'meters' });
            
            // return buffered.features;
            // Simplify the buffered geometry
            // var simplified = turf.simplify(featureCollection, { tolerance: 0.001, highQuality: false });
            // return simplified.features

            // return buffered.features;
        }

        function onDataLoaded(mapGeoJSON, mappedDataSetConfigs, mappedDataSets) {
            // The things we want to draw
            mapFeatures = topojson.feature(mapGeoJSON, mapGeoJSON.objects.wpc).features
            mapFeatures = simplifyMapFeaturesOld(mapFeatures);

            // Cache the drawing information
            allDataSetsCachedData = [];
            for (const dataSet of mappedDataSets) {
                dataSetCachedData = {};
                dataSetCachedData.root = computeDataSetCachedData(dataSet);
                dataSetCachedData.features = {};
                for (const feature of mapFeatures) {
                    dataSetCachedData.features[feature.id] = computeFeatureData(feature, dataSet, dataSetCachedData.root);
                }
                allDataSetsCachedData.push(dataSetCachedData);
            }

            numDataSets = mappedDataSets.length
            initialDataSet = numDataSets - 1
            const sliderRange = d3.sliderBottom()
                .min(0)
                .max(numDataSets - 1)
                .width(300)
                .ticks(numDataSets)
                .default(initialDataSet)
                .step(1)
                .fill('#85bb65')
                .tickFormat(function (tick) { return mappedDataSetConfigs[tick].id; });
            
            const gRange = d3
                .select('#slider-range')
                .append('svg')
                .attr('width', 500)
                .attr('height', 100)
                .append('g')
                .attr('transform', 'translate(90,30)');

            gRange.call(sliderRange);

            drawMappedData(mapFeatures, allDataSetsCachedData[initialDataSet]);

            sliderRange.on('onchange', val => {
                console.log("onchange", electionFiles[val].filename);
                setMappedData(mapFeatures, allDataSetsCachedData[val]);
            })
        }

        mapGeoJSONFileName = "/data/topo_westminster_parliamentary_constituencies_2014.json";
        electionFiles = [
            {"id": "2005", "filename": "/data/electdata_2005nb.txt"},
            {"id": "2010", "filename": "/data/electdata_2010ug.txt"},
            {"id": "2015", "filename": "/data/electdata_2015.txt"},
            {"id": "2017", "filename": "/data/electdata_2017.txt"},
            {"id": "2019", "filename": "/data/electdata_2019.txt"},
        ];
        
        promises = [];
        promises.push(d3.json(mapGeoJSONFileName));
        for (const electionFile of electionFiles) {
            promises.push(d3.dsv(";", electionFile.filename));
        }

        Promise.all(promises).then(
            function (results) {
                mapGeoJSON = results[0];
                electionFilesData = results.slice(1);
                onDataLoaded(mapGeoJSON, electionFiles, electionFilesData);
            }
        )
    </script>

</body>

</html>